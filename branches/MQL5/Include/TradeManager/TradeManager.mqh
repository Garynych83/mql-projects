//+------------------------------------------------------------------+
//|                                                CTradeManager.mq5 |
//|                                              Copyright 2013, GIA |
//|                                             http://www.saita.net |
//+------------------------------------------------------------------+
#property copyright "Copyright 2013, GIA"
#property link      "http://www.saita.net"
#property version   "1.00"

#include "TradeManagerEnums.mqh"
#include "PositionOnPendingOrders.mqh"
#include "PositionArray.mqh"
#include <Trade\PositionInfo.mqh>
#include <Trade\SymbolInfo.mqh>
#include <CompareDoubles.mqh>
#include <CLog.mqh>
//количество столбцов в файле
#define N_COLUMNS 17
  
//#include <Graph\Graph.mqh>


int error = 0;
//+------------------------------------------------------------------+
//| Временный класс для  хранения вычисленных параметров бэктеста    |
//+------------------------------------------------------------------+
 struct SysParam
  {

   uint nTrades;               //количество трейдов
   uint nDeals;                //количество сделок
   uint nWinTrades;            //количество выйгрышных трейдов
   uint nLoseTrades;           //количество убыточных трейдов
   
   double shortTradeWinPer;    //процент выйгрышных коротких сделок (от выйгрывших)
   double longTradeWinPer;     //процент выйгрышных длинных сделок (от выйгрывших)
   double profitTradesPer;     //процент прибыльный трейдов (от всех)
   double loseTradesPer;       //процент проигравших трейдов (от всех)
   
   double maxWinTrade;         //самый большой выйгравший трейд
   double maxLoseTrade;        //самый большой убыточный трейд
   
   double medWinTrade;         //средний выйгрышный трейд
   double medLoseTrade;        //средний сливший трейд
   
   uint maxWinTradesN;         //максимальное число непрерывных выйгрышей
   uint maxLoseTradesN;        //максимальное число непрерывных проигрышей
   
   double maxWinTradeSum;      //максимальная непрерывная прибыль
   double maxLoseTradeSum;     //максимальный непрерывный убыток
      
  };
  

//+------------------------------------------------------------------+
//| Класс обеспечивает вспомогательные торговые вычисления           |
//+------------------------------------------------------------------+
class CTradeManager
{
protected:
  ulong _magic;
  bool _useSound;
  string _nameFileSound;   // Наименование звукового файла
  datetime _historyStart;
 // GraphModule  graphModule;   //графический модуль
  CPositionArray _positionsToReProcessing; ///массив позиций, находящихся в процессе
  CPositionArray _openPositions;           ///массив текущих открытых позиций
  CPositionArray _positionsHistory;        ///массив истории виртуальных позиций
  

  
  //дополнительные параметры  
  bool _pos_panel_draw;                     //флаг отображения позиции
  
public:

  SysParam tmpParam;   //временное хранение данных

  void CTradeManager(bool pos_panel_draw=false):  _useSound(true), _nameFileSound("expert.wav") 
  {
   _magic = MakeMagic();
   _historyStart = TimeCurrent(); 
   log_file.Write(LOG_DEBUG, StringFormat("%s Создание объекта CTradeManager", MakeFunctionPrefix(__FUNCTION__)));
   log_file.Write(LOG_DEBUG, StringFormat("%s History start: %s", MakeFunctionPrefix(__FUNCTION__), TimeToString(_historyStart))); 
  
  /*
  
   graphModule.RenameGraph("свойства позиции"); //добавляем новый заголовок
   graphModule.SetElem("Мэджик");            //отображаем магическое число        
   graphModule.SetElem("Цена");              //отображаем цену позиции
   graphModule.SetElem("Статус");            //статус позиции
   graphModule.SetElem("Тип");               //тип позиции
   graphModule.SetElem("Стоп лосс");         //стоп лосс
   graphModule.SetElem("Тейк профит");       //отображаем цену позиции
   graphModule.SetElem("Тикет");             //тикет 
   graphModule.SetElem("СтопЛосс статус");   //стоп лосс статус  
   graphModule.SetElem("Время открытия");    //время открытия позиции 
   graphModule.SetElem("Цена открытия");     //цена открытия
   //graphModule.SetElem("Время закрытия");  //время открытия позиции
   
   */
       
   _pos_panel_draw = pos_panel_draw;
  };
  
  //временные методы для вычисления бэктеста
  
  bool BackTest();   //базовый метод, вычисляющий значения бэктеста
  
  void GetNTrades();          //возвращает количество трейдов в истории                                       (сделано)
  void GetNDeals();           //возвращает количество сделок  
  void GetNWinLoseTrades();   //возвращает количество выйгрышных и убыточных трейдов                          (сделано)
  void GetShortTradeWinPer(); //возвращает процент выйгрышных коротких сделок по отношению ко всем выйгрышным
  void GetLongTradeWinPer();  //возвращает процент выйгрышных длинных сделок по отношению ко всем выйгрышным
  void GetProfitTradesPer();  //возвращает процент прибыльных трейдов по отношению ко всем                    (сделано)
  void GetLoseTradesPer();    //возвращает процент  убыточных трейдов по отношению ко всем                    (сделано)
  void GetMaxWinTrade();      //возвращает самый большой выйгрышный трейд                                     (сделано)
  void GetMaxLoseTrade();     //возвращает самый большой убыточный трейд                                      (сделано)
  void GetMedWinTrade();      //возвращает средний выйгрышный трейд                                           (сделано)
  void GetMedLoseTrade();     //возвращает средний убыточный трейд                                            (сделано)
  void GetMaxWinTradesN();    //возвращает максимальное число непрерывных выйгрышных трейдов                  (сделано)
  void GetMaxLoseTradesN();    //возвращает максимальное число непрерывных убыточных трейдов                  (сделано)
  void GetMaxWinTradeSum();   //возвращает максимальную су
  void GetMaxLoseTradeSum();  //максимальный непрерывный убыток  
  
  void   ZeroParam();          //очищает параметры бэктеста
  
  void   ShowBackTestResults();  //отображает вычисленные значения бэктеста
  
  //базовые методы TradeManager
  
  bool OpenPosition(string symbol, ENUM_TM_POSITION_TYPE type,double volume ,int sl, int tp, 
                    int minProfit, int trailingStop, int trailingStep, int priceDifference = 0);
  void ModifyPosition(ENUM_TRADE_REQUEST_ACTIONS trade_action);
  bool ClosePosition(long ticket, color Color=CLR_NONE);     // Закртыие позиции по тикету
  bool ClosePosition(int i,color Color=CLR_NONE);            // Закрытие позиции по индексу в массиве позиций
  bool ClosePosition(string symbol, color Color=CLR_NONE);   // Закрытие позиции по символу 
  bool CloseReProcessingPosition(int i,color Color=CLR_NONE);
  long MakeMagic(string strSymbol = "");
  void DoTrailing();
  void Initialization();
  void Deinitialization();
  bool isMinProfit(string symbol);
  void OnTick();
  void OnTrade(datetime history_start);
  void SaveSituationToFile();
  bool LoadHistoryFromFile(); //считывает историю из файла
  private:
  ENUM_TM_POSITION_TYPE GetPositionType(string symbol);
  void SaveHistoryToFile();
  void DrawCurrentPosition(int index);  //отображение текущей позиции
};
//+------------------------------------------------------------------+
//| Временные методы вычисления бэктеста                             |
//+------------------------------------------------------------------+

void CTradeManager::GetNTrades(void)      //получает количество трейдов
 {
   tmpParam.nTrades = _positionsHistory.Total();
 }
 
void CTradeManager::GetLoseTradesPer(void)  //вычисляет процент убыточных трейдов по отношению ко всем
 {
  tmpParam.loseTradesPer = (double)(int)(tmpParam.nLoseTrades/tmpParam.nTrades);
 } 
 
void CTradeManager::GetProfitTradesPer(void)  //вычисляет процент выйгрышных трейдов по отношению ко всем
 {
  tmpParam.profitTradesPer = (double)(int)(tmpParam.nWinTrades/tmpParam.nTrades);
 }  
 
void CTradeManager::GetNWinLoseTrades(void)   //получает количество выйгрышных и убыточных трейдов
 {
   uint index;
   tmpParam.nWinTrades = 0;    //обнуляем количество выйгрышных трейдов
   tmpParam.nLoseTrades = 0;   //обнуляем количество убыточных трейдов   
   GetNTrades();               //вычисляем количество трейдов
   uint total = tmpParam.nTrades;
   CPosition * pos;          //указатель на позицию
   for (index=0;index<total;index++)
    {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу
    //если выйгрышный трейд
    if (pos.getPosProfit()>0) 
     tmpParam.nWinTrades++;  //увеличиваем счетчик выйгрышных трейдов на единицу
    //если убыточный трейд
    if (pos.getPosProfit()<0) 
     tmpParam.nLoseTrades++;  //увеличиваем счетчик убыточных трейдов на единицу     
    }   
 } 


void CTradeManager::GetMaxWinTrade(void) //вычисляет самый большой выйгрышный трейд
 {
   uint index;
   GetNTrades(); //вычисляем количество трейдов
   uint total = tmpParam.nTrades;
   CPosition * pos;  //указатель на позицию
   tmpParam.maxWinTrade = 0;
   Alert("N TRADES = ",total);
   for (index=0;index<total;index++)
    {
     Alert("<<<< ",index);
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу
    //вычисление самого большого выйгрышного трэйда
    if (pos.getPosProfit()>tmpParam.maxWinTrade)
     tmpParam.maxWinTrade = pos.getPosProfit();
    }
 }
 
void CTradeManager::GetMaxLoseTrade(void) //вычисляет самый большой убыточный трейд
 {
   uint index;
   GetNTrades(); //вычисляем количество трейдов
   uint total = tmpParam.nTrades;
   CPosition * pos;  //указатель на позицию
   tmpParam.maxLoseTrade = 0;   
   for (index=0;index<total;index++)
    {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу
    //вычисление самого большого выйгрышного трэйда
    if ( pos.getPosProfit()<tmpParam.maxLoseTrade)
     tmpParam.maxLoseTrade = pos.getPosProfit();
    }
 } 

void CTradeManager::GetMedWinTrade(void)  //вычисляет средний выйгрышный трейд
 {
   uint index;
   uint count=0;   //счетчик выйгрышных трейдов
   GetNTrades(); //вычисляем количество трейдов
   uint total = tmpParam.nTrades;
   double profitSum=0; //сумма профитов 
   CPosition * pos;  //указатель на позицию
   for (index=0;index<total;index++)
    {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу
    //вычисление самого большого выйгрышного трэйда
    if (pos.getPosProfit()>0)  //если трейд - выйгрышный
     {
      profitSum = profitSum + pos.getPosProfit();
      count++;
     }
    } 
    if (count) //если количество выйгрышных трейдов больше нуля
    tmpParam.medWinTrade = profitSum/count; //вычисляем средний выйгрышный трейд
 } 
 
void CTradeManager::GetMedLoseTrade(void)  //вычисляет средний убыточный трейд
 {
   uint index;
   uint count=0;   //счетчик убыточных трейдов
   GetNTrades(); //вычисляем количество трейдов
   uint total = tmpParam.nTrades;
   double profitSum=0; //сумма профитов 
   CPosition * pos;  //указатель на позицию
   for (index=0;index<total;index++)
    {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу
    //вычисление самого большого выйгрышного трэйда
    if (pos.getPosProfit()<0)  //если трейд - убыточный
     {
      profitSum = profitSum + pos.getPosProfit();
      count++;
     }
    } 
    if (count) //если количество убыточных трейдов больше нуля
    tmpParam.medLoseTrade = profitSum/count; //вычисляем средний убыточный трейд
 }  


void CTradeManager::GetMaxWinTradesN(void)  //вычисляет  максимальное количество подряд идуших выйгрышных трейдов
 {
  uint count=0;                   //текущее число подряд идущих трейдов
  uint index;                     //индекс по массиву позиций
  CPosition * pos;                //указатель на позицию
  GetNTrades();                   //вычисляет количество трейдов (позиций) в истории
  uint total = tmpParam.nTrades;  //количество позиций в истории
  tmpParam.maxWinTradesN = 0;     //обнуляем максимальное число подряд идущих прибыльных трейдов
  for (index=0;index<total;index++)
   {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу    
    if (pos.getPosProfit()>0) count++;  //если выйгрышный трейд, то считаем
    else //иначе
     {
      if (count>0) //счетчик положительный, значит прошлый трейд был выйгрышным
       {
        if (count > tmpParam.maxWinTradesN) //если найдено большее количество подряд идущих трейдов
         tmpParam.maxWinTradesN = count;
        count = 0; //обнуляем счетчик
       }
     }
   }
  if (count > tmpParam.maxWinTradesN)  
   tmpParam.maxWinTradesN = count;
 }
 
void CTradeManager::GetMaxLoseTradesN(void)  //вычисляет  максимальное количество подряд идуших убыточных трейдов
 {
  uint count=0;                   //текущее число подряд идущих трейдов
  uint index;                     //индекс по массиву позиций
  CPosition * pos;                //указатель на позицию
  GetNTrades();                   //вычисляет количество трейдов (позиций) в истории
  uint total = tmpParam.nTrades;  //количество позиций в истории
  tmpParam.maxLoseTradesN = 0;     //обнуляем максимальное число подряд идущих убыточных трейдов
  for (index=0;index<total;index++)
   {
    pos  = _positionsHistory.Position(index); //указатель на позицию по индексу    
    if (pos.getPosProfit()<0) count++;  //если  убыточный трейд, то считаем
    else //иначе
     {
      if (count>0) //счетчик положительный, значит прошлый трейд был убыточным
       {
        if (count > tmpParam.maxLoseTradesN) //если найдено большее количество подряд идущих трейдов
         tmpParam.maxLoseTradesN = count;
        count = 0; //обнуляем счетчик
       }
     }
   }
  if (count > tmpParam.maxLoseTradesN)  
   tmpParam.maxLoseTradesN = count;
 } 
 
   void CTradeManager::ZeroParam(void)  //обнуляет все параметры бэктеста
   {
     tmpParam.nTrades=0;             //количество трейдов
     tmpParam.nDeals=0;              //количество сделок
   
     tmpParam.shortTradeWinPer=0;    //процент выйгрышных коротких сделок (от выйгрывших)
     tmpParam.longTradeWinPer=0;     //процент выйгрышных длинных сделок (от выйгрывших)
     tmpParam.profitTradesPer=0;     //процент прибыльный трейдов (от всех)
     tmpParam.loseTradesPer=0;       //процент проигравших трейдов (от всех)
   
     tmpParam.maxWinTrade=0;         //самый большой выйгравший трейд
     tmpParam.maxLoseTrade=0;        //самый большой убыточный трейд
   
     tmpParam.medWinTrade=0;         //средний выйгрышный трейд
     tmpParam.medLoseTrade=0;        //средний сливший трейд
   
     tmpParam.maxWinTradesN=0;       //максимальное число непрерывных выйгрышей
     tmpParam.maxLoseTradesN=0;      //максимальное число непрерывных проигрышей
   
     tmpParam.maxWinTradeSum=0;      //максимальная непрерывная прибыль
     tmpParam.maxLoseTradeSum=0;     //максимальный непрерывный убыток   
   }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool CTradeManager::OpenPosition(string symbol, ENUM_TM_POSITION_TYPE type, double volume,int sl, int tp, 
                                 int minProfit, int trailingStop, int trailingStep, int priceDifferense = 0)
{
 if (_positionsToReProcessing.Total() > 0) 
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Невозможно открыть позицию так как еще есть позиции в positionsToReProcessing.", MakeFunctionPrefix(__FUNCTION__)));
  return false;
 }

 int i = 0;
 int total = _openPositions.Total();
 CPosition *pos;
 log_file.Write(LOG_DEBUG
               ,StringFormat("%s, Открываем позицию %s. Открытых позиций на данный момент: %d"
                            , MakeFunctionPrefix(__FUNCTION__), GetNameOP(type), total));
 log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), _openPositions.PrintToString())); // Распечатка всех позиций из массива _openPositions
 switch(type)
 {
  case OP_BUY:
  case OP_BUYLIMIT:
  case OP_BUYSTOP:
   if (total > 0)
   {
    for (i = total - 1; i >= 0; i--) // Закрываем все ордера или позиции на продажу
    {
     pos = _openPositions.At(i);
     if (pos.getSymbol() == symbol)
     {
      if (pos.getType() == OP_SELL)
      {
       ClosePosition(i);
      }
      else
      {
       if (pos.getType() == OP_SELLLIMIT || pos.getType() == OP_SELLSTOP)
       {
        ResetLastError();
        if(OrderSelect(pos.getPositionTicket()))
        {
         ClosePosition(i);
        }
        else
        {
         log_file.Write(LOG_DEBUG ,StringFormat("%s, Закрытие позиции не удалось: Не выбран ордер с тикетом %d. Ошибка %d - %s"
                       , MakeFunctionPrefix(__FUNCTION__), pos.getPositionTicket()
                       , GetLastError(), ErrorDescription(GetLastError())));
        }
       }
      }
     }
    }
   }
   break;
  case OP_SELL:
  case OP_SELLLIMIT:
  case OP_SELLSTOP:
   if (total > 0)
   {
    for (i = total - 1; i >= 0; i--) // Закрываем все ордера или позиции на покупку
    {
     pos = _openPositions.At(i);
     if (pos.getSymbol() == symbol)
     {
      if (pos.getType() == OP_BUY)
      {
       ClosePosition(i);
      }
      else
      {
       if (pos.getType() == OP_BUYLIMIT || pos.getType() == OP_BUYSTOP)
       {
        ResetLastError();
        if(OrderSelect(pos.getPositionTicket()))
        {
         ClosePosition(i);
        }
        else
        {
         log_file.Write(LOG_DEBUG ,StringFormat("%s, Закрытие позиции не удалось: Не выбран ордер с тикетом %d. Ошибка %d - %s"
                        , MakeFunctionPrefix(__FUNCTION__), pos.getPositionTicket()
                        , GetLastError(), ErrorDescription(GetLastError())));
        }
       }
      }
     }
    }
   }
   break;
  default:
   //log_file.Write(LOG_DEBUG, StringFormat("%s Error: Invalid ENUM_VIRTUAL_ORDER_TYPE", MakeFunctionPrefix(__FUNCTION__)));
   break;
 }
 
 total = _openPositions.OrderCount(symbol, _magic) + _positionsToReProcessing.OrderCount(symbol, _magic);
 if (total <= 0)
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s openPositions и positionsToReProcessing пусты - открываем новую позицию", MakeFunctionPrefix(__FUNCTION__)));
  pos = new CPosition(_magic, symbol, type, volume, sl, tp, minProfit, trailingStop, trailingStep, priceDifferense);
  ENUM_POSITION_STATUS openingResult = pos.OpenPosition();
  if (openingResult == POSITION_STATUS_OPEN || openingResult == POSITION_STATUS_PENDING) // удалось установить желаемую позицию
  {
   log_file.Write(LOG_DEBUG, StringFormat("%s, magic=%d, symb=%s, type=%s, price=%.05f vol=%.02f, sl=%.05f, tp=%.05f"
                                          , MakeFunctionPrefix(__FUNCTION__), pos.getMagic(), pos.getSymbol(), GetNameOP(pos.getType()), pos.getPositionPrice(), pos.getVolume(), pos.getStopLossPrice(), pos.getTakeProfitPrice()));


   _openPositions.Add(pos);  // добавляем открытую позицию в массив открытых позиций
   SaveSituationToFile();
   log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), _openPositions.PrintToString()));
   return(true); // Если удачно открыли позицию
  }
  else
  {
   error = GetLastError();
   if(pos.getType() == OP_SELL || pos.getType() == OP_BUY) _positionsToReProcessing.Add(pos);
   log_file.Write(LOG_DEBUG, StringFormat("%s Не удалось открыть позицию. Error{%d} = %s. Status = %s", MakeFunctionPrefix(__FUNCTION__), error, ErrorDescription(error), PositionStatusToStr(pos.getPositionStatus())));
   return(false); // Если открыть позицию не удалось
  }
 }
 log_file.Write(LOG_DEBUG, StringFormat("%s Осталось открытых позиций %d", MakeFunctionPrefix(__FUNCTION__), total));
 return(true); // Если остались открытые позиции, значит не надо открываться 
}
//+------------------------------------------------------------------+ 
// Функция вычисления параметров трейлинга
//+------------------------------------------------------------------+
void CTradeManager::DoTrailing()
{
 int total = _openPositions.Total();
//--- пройдем в цикле по всем ордерам
 for(int i = 0; i < total; i++)
 {
  CPosition *pos = _openPositions.At(i);
  if(pos.DoTrailing())
  {
   log_file.Write(LOG_DEBUG, StringFormat("%s Изменился SL позиции [%d]", MakeFunctionPrefix(__FUNCTION__), i));
   log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), _openPositions.PrintToString()));
  }
 } 
};
//+------------------------------------------------------------------+ 
// Функция модификации позиции
//+------------------------------------------------------------------+
void CTradeManager::ModifyPosition(ENUM_TRADE_REQUEST_ACTIONS trade_action)
{
 
};

//+------------------------------------------------------------------+
/// Called from EA OnTrade().
/// Include the folowing in each EA that uses TradeManager
//+------------------------------------------------------------------+
void CTradeManager::OnTrade(datetime history_start=0)
{
/*
 if (_pos_panel_draw) 
  DrawCurrentPosition(_openPositions.Total()-1);  //отображаем панель свойств позиции
*/
}

//+------------------------------------------------------------------+
/// Called from EA OnTick().
/// Actions virtual positions 
/// Include the folowing in each EA that uses TradeManage
//+------------------------------------------------------------------+
void CTradeManager::OnTick()
{
//--- Сначала обработаем незавершенные позиции
 int total = _positionsToReProcessing.Total();
 for(int i = total - 1; i>=0; i--) // по массиву позиций на доработку
 {
  CPosition *pos = _positionsToReProcessing.Position(i);  // получаем из массива указатель на позицию по ее тикету
  if (pos.getPositionStatus() == POSITION_STATUS_NOT_DELETED)
  {
   if (pos.RemovePendingPosition() == POSITION_STATUS_DELETED)
   {
    log_file.Write(LOG_DEBUG, StringFormat("%s Получилось удалить позицию [%d].Удаляем её из positionsToReProcessing.", MakeFunctionPrefix(__FUNCTION__), i));
              //       pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
              //       pos.pos_closed = true;
                    
                    // pos.setPriceClose(SymbolInfoDouble(pos.getSymbol(),SYMB
/*ADD TO HISTORY*/
   //_positionsHistory.Add(_positionsToReProcessing.Detach(i)); //добавляем удаляемую позицию в массив
   _positionsToReProcessing.Delete(i);   
    SaveHistoryToFile();                  
    break;
   }
  }
  
  if (pos.getStopLossStatus() == STOPLEVEL_STATUS_NOT_DELETED)
  {
   log_file.Write(LOG_DEBUG, StringFormat("%s Удаляем StopLoss и TakeProfit", MakeFunctionPrefix(__FUNCTION__)));    
   CloseReProcessingPosition(i);
   break;
  }
  
  if (pos.getPositionStatus() == POSITION_STATUS_NOT_COMPLETE)
  {
   if (pos.setStopLoss() != STOPLEVEL_STATUS_NOT_PLACED && pos.setTakeProfit() != STOPLEVEL_STATUS_NOT_PLACED)
   {
    log_file.Write(LOG_DEBUG, StringFormat("%s Получилось установить StopLoss и TakeProfit у позиции [%d].Перемещаем её из positionsToReProcessing в openPositions.", MakeFunctionPrefix(__FUNCTION__), i));    
    pos.setPositionStatus(POSITION_STATUS_OPEN);
  
    _openPositions.Add(_positionsToReProcessing.Detach(i));    
    SaveSituationToFile();
   }
  }
 } 

//--- Подгружаем историю
 if(!HistorySelect(_historyStart, TimeCurrent()))
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Не получилось выбрать историю с %s по %s", MakeFunctionPrefix(__FUNCTION__), _historyStart, TimeCurrent())); 
  return;
 }

//--- Если история подгрузилась, работаем с текущими позициями  
 total = _openPositions.Total();
 CPosition *pos;
//--- по массиву НАШИХ позиций
 for(int i = total - 1; i >= 0; i--) 
 {
  pos = _openPositions.At(i);   // выберем позицию по ее индексу
  ENUM_TM_POSITION_TYPE type = pos.getType();
  
  if (!OrderSelect(pos.getStopLossTicket()) && pos.getPositionStatus() != POSITION_STATUS_PENDING && pos.getStopLossStatus() != STOPLEVEL_STATUS_NOT_DEFINED) // Если мы не можем выбрать стоп по его тикету, значит он сработал
  {
   log_file.Write(LOG_DEBUG, StringFormat("%s Нет ордера-StopLoss, удаляем позицию [%d]", MakeFunctionPrefix(__FUNCTION__), i));
                   //  pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
                   //  pos.pos_closed = true;
/*ADD TO HISTORY*/    _positionsHistory.Add(_openPositions.Detach(i));   
    SaveHistoryToFile();  
   SaveSituationToFile();               // Переписать файл состояния
   break;                          
  }
  
  if (pos.CheckTakeProfit())    //проверяем условие выполнения TP
  {
   log_file.Write(LOG_DEBUG, StringFormat("%s Цена дошла до уровня TP, закрываем позицию type = %s, TPprice = %f", MakeFunctionPrefix(__FUNCTION__), GetNameOP(type),  pos.getTakeProfitPrice()));
   ClosePosition(i);
   break;             
  }
     
  if (pos.getPositionStatus() == POSITION_STATUS_PENDING) // Если это позиция отложенным ордером...
  {
   if (!OrderSelect(pos.getPositionTicket())) // Если мы не можем выбрать ее по тикету
   {
    long ticket = pos.getPositionTicket();
    if(!FindHistoryTicket(ticket))            // Попробуем найти этот тикет в истории
    {
     log_file.Write(LOG_DEBUG, StringFormat("%s В массиве историй не найден ордер с тикетом %d", MakeFunctionPrefix(__FUNCTION__), ticket));
     return;
    }
    
    long state;
    if (HistoryOrderGetInteger(ticket, ORDER_STATE, state)) // Получим статус ордера из истории
    {
     switch (state)
     {
      case ORDER_STATE_FILLED:
      {
       log_file.Write(LOG_DEBUG, StringFormat("%s Сработала позиция являющаяся отложенным ордером.Пытаемся установить StopLoss и TakeProfit.", MakeFunctionPrefix(__FUNCTION__)));
       
       if (pos.setStopLoss() == STOPLEVEL_STATUS_NOT_PLACED
        || pos.setTakeProfit() == STOPLEVEL_STATUS_NOT_PLACED )  // попробуем установить стоплосс и тейкпрофит
       {
        log_file.Write(LOG_DEBUG, StringFormat("%s Не получилось установить StopLoss и/или TakeProfit. Перемещаем позицию [%d] в positionsToReProcessing.", MakeFunctionPrefix(__FUNCTION__)));                  
        pos.setPositionStatus(POSITION_STATUS_NOT_COMPLETE);  // если не получилось, запомним, чтобы повторить позднее
        _positionsToReProcessing.Add(_openPositions.Detach(i)); 
        break;
       }
       
       log_file.Write(LOG_DEBUG, StringFormat("%s Получилось установить StopLoss и/или TakeProfit. Изменяем позицию [%d] в openPositions.", MakeFunctionPrefix(__FUNCTION__)));
       pos.setPositionStatus(POSITION_STATUS_OPEN); // позиция открылась, стоп и тейк установлены
       if (pos.getType() == OP_BUYLIMIT || pos.getType() == OP_BUYSTOP) pos.setType(OP_BUY);
       if (pos.getType() == OP_SELLLIMIT || pos.getType() == OP_SELLSTOP) pos.setType(OP_SELL);
       log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), _openPositions.PrintToString()));
       SaveSituationToFile();
       break;
      }
      case ORDER_STATE_CANCELED:
      {
       log_file.Write(LOG_DEBUG, StringFormat("%s ордер отменен %d STATE = %s", MakeFunctionPrefix(__FUNCTION__), pos.getPositionTicket(), EnumToString((ENUM_ORDER_STATE)HistoryOrderGetInteger(pos.getPositionTicket(), ORDER_STATE))));
                 //    pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
                 //    pos.pos_closed = true; 
/*ADD TO HISTORY*/   _positionsHistory.Add(_openPositions.Detach(i));
                     SaveHistoryToFile();  
       break;
      }
      case ORDER_STATE_EXPIRED:
      {
       log_file.Write(LOG_DEBUG, StringFormat("%s прошло время ожидания %d STATE = %s", MakeFunctionPrefix(__FUNCTION__), pos.getPositionTicket(), EnumToString((ENUM_ORDER_STATE)HistoryOrderGetInteger(pos.getPositionTicket(), ORDER_STATE))));
                 //    pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
                 //    pos.pos_closed = true; 
/*ADD TO HISTORY*/   _positionsHistory.Add(_openPositions.Detach(i));
                     SaveHistoryToFile();  
       break;
      }
      
      default:
      {
       log_file.Write(LOG_DEBUG, StringFormat("%s Плохой статус оредера при перемещении в историю: %s; тикет ордера: %d", MakeFunctionPrefix(__FUNCTION__), EnumToString((ENUM_ORDER_STATE)state), ticket));
       break;
      }
     }
    }
    else
    {
     log_file.Write(LOG_DEBUG, StringFormat("%s Не получилось выбрать ордер по тикету %d из истории", MakeFunctionPrefix(__FUNCTION__), pos.getPositionTicket()));
     log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), ErrorDescription(GetLastError())));
     string str;
     int total = HistoryOrdersTotal();
     for(int i = total-1; i >= 0; i--)
     {
      str += HistoryOrderGetTicket(i) + " ";
     }
     log_file.Write(LOG_DEBUG, StringFormat("%s Тикеты ордеров из истории: %s", MakeFunctionPrefix(__FUNCTION__), str));
    } 
   }
  }
 }


 
}

//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
void CTradeManager::Initialization()
{
 log_file.Write(LOG_DEBUG, StringFormat("%s Запущен процесс инициализации.", MakeFunctionPrefix(__FUNCTION__)));
 int file_handle = FileOpen(CreateRDFilename(), FILE_READ|FILE_CSV|FILE_COMMON, ";");
 if (file_handle != INVALID_HANDLE)
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Существует файл состояния. Считываем данные из него.", MakeFunctionPrefix(__FUNCTION__)));
  _openPositions.ReadFromFile(file_handle);
  FileClose(CreateRDFilename());
  log_file.Write(LOG_DEBUG, StringFormat("%s Скопировали данные из файла состояния.", MakeFunctionPrefix(__FUNCTION__)));
  //SaveSituationToFile(true);
  log_file.Write(LOG_DEBUG, StringFormat("%s %s", MakeFunctionPrefix(__FUNCTION__), _openPositions.PrintToString()));
 }
 else
  log_file.Write(LOG_DEBUG, StringFormat("%s Файл состояния отсутствует.Предыдущее завершенее программы было корректным.", MakeFunctionPrefix(__FUNCTION__)));
}

//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
void CTradeManager::Deinitialization()
{
 log_file.Write(LOG_DEBUG, StringFormat("%s Запущен процесс деинициализации.", MakeFunctionPrefix(__FUNCTION__)));
 int size = _openPositions.Total();
 int attempts = 0;
 while (attempts < 25)
 {
  for(int i = size - 1; i>=0; i--) // по массиву НАШИХ позиций
  {
   ClosePosition(i);
  }
  size = _openPositions.Total();
  if(size == 0) break;
  attempts++;
 }
 log_file.Write(LOG_DEBUG, StringFormat("%s Процесс деинициализации завершен.", MakeFunctionPrefix(__FUNCTION__)));
 FileDelete(CreateRDFilename(), FILE_COMMON);
}
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
bool CTradeManager::isMinProfit(string symbol)
{
 int total = _openPositions.Total();
 CPosition *pos;
 for (int i = 0; i < total; i++)
 {
  pos = _openPositions.At(i);
  if (pos.getSymbol() == symbol)
  {
   return(pos.isMinProfit());
  }
 }
 return false;
}
//+------------------------------------------------------------------+
/// Close a virtual order.
/// \param [in] ticket			Open virtual order ticket
/// \param [in] arrow_color 	Default=CLR_NONE. This parameter is provided for MT4 compatibility and is not used.
/// \return							true if successful, false if not
//+------------------------------------------------------------------+
bool CTradeManager::ClosePosition(long ticket, color Color=CLR_NONE)
{
 int index = _openPositions.TicketToIndex(ticket);
 return ClosePosition(index);
}

//+------------------------------------------------------------------+
/// Close a virtual order.
/// \param [in] symbol			current symbol
/// \param [in] arrow_color 	Default=CLR_NONE. This parameter is provided for MT4 compatibility and is not used.
/// \return							true if successful, false if not
//+------------------------------------------------------------------+
bool CTradeManager::ClosePosition(string symbol, color Color=CLR_NONE)
{
 int total = _openPositions.Total();
 CPosition *pos;
 for (int i = 0; i < total; i++)
 {
  pos = _openPositions.At(i);
  if (pos.getSymbol() == symbol)
  {
   return(ClosePosition(i));
  }
 }
 return false;
}

//+------------------------------------------------------------------+
/// Close a virtual order.
/// \param [in] i			      pos index in array of positions
/// \param [in] arrow_color 	Default=CLR_NONE. This parameter is provided for MT4 compatibility and is not used.
/// \return							true if successful, false if not
//+------------------------------------------------------------------+
bool CTradeManager::ClosePosition(int i,color Color=CLR_NONE)
{
 CPosition *pos = _openPositions.Position(i);  // получаем из массива указатель на позицию по ее индексу
 if (pos.ClosePosition())
 {
                  //   pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
                   //  pos.setClosePosDT(0);
                   //  pos.pos_closed = true; 
                  //   pos.setPosProfit(PositionGetDouble(POSITION_PROFIT)); //сохраняем прибыль по позиции
/*ADD TO HISTORY*/   _positionsHistory.Add(_openPositions.Detach(i));  //перемещаем удаленную позицию в массив истории позиций
                     SaveHistoryToFile();  
  SaveSituationToFile();
  log_file.Write(LOG_DEBUG, StringFormat("%s Удалена позиция [%d]", MakeFunctionPrefix(__FUNCTION__), i));
  return(true);
 }
 else
 {
  error = GetLastError();
  _positionsToReProcessing.Add(_openPositions.Detach(i));
  log_file.Write(LOG_DEBUG, StringFormat("%s Не удалось удалить позицию [%d]. Позиция перемещена в массив positionsToReProcessing.Error{%d} = %s"
                                        , MakeFunctionPrefix(__FUNCTION__), i, error, ErrorDescription(error)));
 }
 return(false);
}

//+------------------------------------------------------------------+
/// Delete a virtual pos from "not_deleted".
/// \param [in] i			      pos index in array of positions
/// \param [in] arrow_color 	Default=CLR_NONE. This parameter is provided for MT4 compatibility and is not used.
/// \return							true if successful, false if not
//+------------------------------------------------------------------+
bool CTradeManager::CloseReProcessingPosition(int i,color Color=CLR_NONE)
{
 CPosition *pos = _positionsToReProcessing.Position(i);  // получаем из массива указатель на позицию по ее индексу
 if (pos.RemoveStopLoss() == STOPLEVEL_STATUS_DELETED)
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Удалили сработавший стоп-ордер", MakeFunctionPrefix(__FUNCTION__)));
                 //    pos.setClosePosDT(TimeCurrent());  //сохраняем время закрытия
                 //    pos.pos_closed = true; 
/*ADD TO HISTORY*/  _positionsHistory.Add(_positionsToReProcessing.Detach(i));
                    SaveHistoryToFile();  
  return(true);
 }
 return(false);
}
//+------------------------------------------------------------------+
/// Create magic number
/// \param [string] str       symbol
/// \return							generated magic number
//+------------------------------------------------------------------+
long CTradeManager::MakeMagic(string strSymbol = "")
{
 if(strSymbol == "") strSymbol = Symbol();
 string s = strSymbol + PeriodToString(Period()) + MQL5InfoString(MQL5_PROGRAM_NAME);
 ulong ulHash = 5381;
 for(int i = StringLen(s) - 1; i >= 0; i--)
 {
  ulHash = ((ulHash<<5) + ulHash) + StringGetCharacter(s,i);
 }
 return MathAbs((long)ulHash);
}

//+------------------------------------------------------------------+
/// Create file name
/// \return							generated string
//+------------------------------------------------------------------+
string CreateRDFilename ()
{
 string result;
 result = StringFormat("%s\\RescueData\\%s_%s_%s_rd.csv", MQL5InfoString(MQL5_PROGRAM_NAME), MQL5InfoString(MQL5_PROGRAM_NAME), StringSubstr(Symbol(),0,6), PeriodToString(Period()));
 return(result);
}

string CreateHistoryFilename ()
{
 string result;
 result = StringFormat("%s\\History\\%s_%s_%s_history.csv", MQL5InfoString(MQL5_PROGRAM_NAME), MQL5InfoString(MQL5_PROGRAM_NAME), StringSubstr(Symbol(),0,6), PeriodToString(Period()));
 return(result);
}

//+------------------------------------------------------------------+
/// Save position array to file
/// \param [bool] debug       if want to debug
//+------------------------------------------------------------------+
void CTradeManager::SaveSituationToFile()
{
 string file_name = CreateRDFilename();
 int file_handle = FileOpen(file_name, FILE_WRITE|FILE_CSV|FILE_COMMON, ";");
 if(file_handle == INVALID_HANDLE)
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Не получилось открыть файл: %s", MakeFunctionPrefix(__FUNCTION__), file_name));
  return;
 }
 _openPositions.WriteToFile(file_handle);
 FileClose(file_handle);
}

//+------------------------------------------------------------------+
/// Search for ticket in History
/// \param [long] ticket       number of ticket to search
/// \return                    true if successful, false if not
//+------------------------------------------------------------------+
bool FindHistoryTicket(long ticket)
{
 int total = HistoryOrdersTotal();
 for(int i = 0; i < total; i++)
 {
  if(ticket == HistoryOrderGetTicket(i)) return true;  
 }
 return false;
}
//+------------------------------------------------------------------+
/// Return current position type
/// \param [long] ticket       number of ticket to search
/// \return                    true if successful, false if not
//+------------------------------------------------------------------+
ENUM_TM_POSITION_TYPE CTradeManager::GetPositionType(string symbol)
{
  int total = _openPositions.Total();
 CPosition *pos;
 for (int i = 0; i < total; i++)
 {
  pos = _openPositions.At(i);
  if (pos.getSymbol() == symbol)
  {
   return(pos.getType());
  }
 }
 return OP_UNKNOWN;
}

bool CTradeManager::LoadHistoryFromFile()   //загружает историю позиции из файла
 {
  string historyUrl = CreateHistoryFilename(); 
  int file_handle;   //файловый хэндл
  int ind;
  string tmp_str[17];
  bool read_flag;  //флаг считывания данных из файла
  CPosition *pos;  
     if (!FileIsExist(historyUrl,FILE_COMMON) ) //проверка существования файла истории 
      return false;   
   file_handle = FileOpen(historyUrl, FILE_READ|FILE_COMMON|FILE_CSV|FILE_ANSI, ";");
   if (file_handle == INVALID_HANDLE) //не удалось открыть файл
    return false;
   _positionsHistory.Clear(); //очищаем массив истории позиций
   for(ind=0;ind<N_COLUMNS;ind++) //N_COLUMNS - количество столбцов 
    {
    tmp_str[ind] = FileReadString(file_handle);  //пропуск первой строки таблицы
    } 
    /*
   Alert("11 = ", tmp_str[11],
         " 12 = ", tmp_str[12],
         " 13 = ", tmp_str[13],
         " 14 = ", tmp_str[14],
         " 15 = ", tmp_str[15],
         " 16 = ", tmp_str[16],
         " 6 = ", tmp_str[17],
         " 7 = ", tmp_str[1],
         " 8 = ", tmp_str[2],
         " 9 = ", tmp_str[3],
         " 10 = ", tmp_str[4],
         " 11 = ", tmp_str[5],
         " 12 = ", tmp_str[12],
         " 13 = ", tmp_str[13],
         " 14 = ", tmp_str[14],
         " 15 = ", tmp_str[15],
         " 16 = ", tmp_str[16]       
                );*/ 
   read_flag = true;      //как минимум одну строку мы должны попытаться считать
   
   while (read_flag)
    {
     pos = new CPosition(0,"",OP_UNKNOWN,0);    //выделяем память под новый элемент 
     read_flag = pos.ReadFromFile(file_handle); //считываем строку для одной позиции
     if (read_flag)                             //если удалось считать строку 
      _positionsHistory.Add(pos);               //то добавляем элемент в массив историй 
    }   
   FileClose(file_handle);  //закрывает файл истории позиций 
  return true;
 }

void CTradeManager::SaveHistoryToFile(void) //сохраняет историю открытия\закрытия позиций в файл
 { /*
 int file_handle = FileOpen(CreateHistoryFilename(), FILE_WRITE|FILE_COMMON|FILE_CSV|FILE_ANSI, "");
 int index;
 int total = _positionsHistory.Total(); //получаем количество элементов истории
 string result;
 CPosition *pos; //указатель на позицию

 if(file_handle == INVALID_HANDLE)
 {
  Alert("Не удалось создать файл для сохранения истории позиций");
  return;
 }

     //сохраняем наименования колонок таблицы
     result = "";
     StringConcatenate(result, "Мэджик;",
                               "Символ;",
                               "Тип позиции;",
                               "Лот;",
                               "Тикет позиции;",
                               "Тикет стоп лосс;",
                               "Цена стоп лосс;",
                               "Стоп лосс;",
                               "Цена тейк профита;",
                               "Трейлинг стоп;",
                               "Трейлинг степ;",
                               "Цена открытия позиции;",
                               "Цена закрытия позиции;",
                               "Время открытия позиции;",
                               "Время закрытия позиции;",
                               "Прибыль по позиции;"
                               );                 
  
     FileWrite(file_handle,result); //сохраняем свойства позиции                            
 
   for (index=0;index<_positionsHistory.Total();index++)
    {    
    result = "";
     pos  = _positionsHistory.Position(index); //указатель на позицию
     StringConcatenate(result, 
                       pos.getMagic(), ";",                   //мэджик
                       pos.getSymbol(), ";",                  //символ
                       GetNameOP(pos.getType()), ";",         //тип позиции
                       pos.getVolume(), ";",                  //лот
                       pos.getPositionTicket(), ";",          //тикет позиции
                       pos.getStopLossTicket(), ";",          //тикет стоп лосс                     
                       pos.getStopLossPrice(), ";",           //цена стоп лосс
                       pos.getStopLossStatus(), ";",          //статус стоп лосс 
                       pos.getTakeProfitPrice(),";",          //цена тейк профит
                       pos.getTrailingStop(), ";",            //трейлинг стоп
                       pos.getTrailingStep(), ";",            //трейлинг степ
                       DoubleToString(pos.getPriceOpen(),SymbolInfoInteger(pos.getSymbol(),SYMBOL_DIGITS)), ";",  //цена открытия
                       DoubleToString(pos.getPriceClose(),SymbolInfoInteger(pos.getSymbol(),SYMBOL_DIGITS)), ";", //цена закрытия
                       TimeToString(pos.getOpenPosDT()),";",  //время открытия позиции
                       TimeToString(pos.getClosePosDT()),";", //время закрытия позиции 
                       DoubleToString(pos.getPosProfit(),SymbolInfoInteger(pos.getSymbol(),SYMBOL_DIGITS)),";"    //прибыль по позиции                  
                       );     
                                     
                       
   if(pos.getType() != OP_BUY && pos.getType() != OP_SELL) 
     {
      if(OrderSelect(pos.getPositionTicket()))
        StringConcatenate(result, result, ";",EnumToString((ENUM_ORDER_STATE)OrderGetInteger(ORDER_STATE)));
      else
        StringConcatenate(result, result,";",EnumToString((ENUM_ORDER_STATE)HistoryOrderGetInteger(pos.getPositionTicket(), ORDER_STATE)));
    } 
   else
        StringConcatenate(result, result, ";","Немедленное_исполнение");  
     FileWrite(file_handle,result); //сохраняем свойства позиции
   } 
    FileClose(file_handle); //закрываем файл     
    */
 }
 
 /*
 
void CTradeManager::DrawCurrentPosition(int index)  //отображение текущей позиции и её параметров
 {
 CPosition *pos; //указатель на позицию
 if( index >= 0)
  {
 pos  = _openPositions.Position(index); //указатель на позицию
 //pos  = _openPositions.Position(index);
 graphModule.EditElem("Мэджик",pos.getMagic()); //отображаем магическое число        
 graphModule.EditElem("Цена",pos.getPositionPrice()); //отображаем цену позиции
 graphModule.EditElem("Статус",PositionStatusToStr(pos.getPositionStatus())); //статус позиции
 graphModule.EditElem("Тип",GetNameOP(pos.getType())); //тип позиции
 graphModule.EditElem("Стоп лосс", pos.getStopLossPrice()); //стоп лосс
 graphModule.EditElem("Тейк профит",pos.getTakeProfitPrice()); //отображаем цену позиции
 graphModule.EditElem("Тикет",pos.getStopLossTicket());  //тикет 
 graphModule.EditElem("СтопЛосс статус",pos.getStopLossStatus());  //стоп лосс статус 
 graphModule.EditElem("Время открытия",TimeToString(pos.getOpenPosDT()) );  //время открытия позиции  
 graphModule.EditElem("Цена открытия",pos.getPriceOpen());    //цена открытия  
 //graphModule.EditElem("Время закрытия",TimeToString(pos.getClosePosDT()) );  //время закрытия  позиции    
 
 graphModule.ShowPanel(); //отображаем панель           
  }              
 } 
 */