//+------------------------------------------------------------------+
//|                                                      ONODERA.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              http://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2013, MetaQuotes Software Corp."
#property link      "http://www.mql5.com"
#property version   "1.00"

// подсключение библиотек 
#include <TradeManager\TradeManager.mqh>        // подключение торговой библиотеки
#include <Lib CisNewBar.mqh>                    // для проверки формирования нового бара
#include <CompareDoubles.mqh>                   // для проверки соотношения  цен

#define ADD_TO_STOPPLOSS 50
// константы сигналов
#define BUY   1    
#define SELL -1
//+------------------------------------------------------------------+
//| Эксперт, основанный на расхождении Стохастика                    |
//+------------------------------------------------------------------+

// входные параметры
sinput string order_params                         = "";                 // ПАРАМЕТРЫ ОРДЕРОВ
input  bool   use_limits                           = true;               // использование limit-ордеров
input  bool   flat_as_instant                      = false;              // открываться на FLAT по направлению расхождения

sinput string pbi_Str                              = "";                 // ПАРАМЕТРЫ PBI
input double  percentage_ATR_cur                   = 2;   
input double  difToTrend_cur                       = 1.5;
input int     ATR_ma_period_cur                    = 12;

// объекты
CTradeManager    *ctm;                                                   // указатель на объект торговой библиотеки
static CisNewBar *isNewBar;                                              // для проверки формирования нового бара

// хэндлы индикаторов 
int handleSmydSTOC;                                                      // хэндл индикатора ShowMeYourDivSTOC
int handlePBIcur;                                                        // хэндл PriceBasedIndicator

// переменные эксперта
double currentPrice;        // текущая цена
string symbol;              // текущий символ
ENUM_TIMEFRAMES period;     // текущий период
int historyDepth;           // глубина истории
int priceDifference;        // Price Difference
ENUM_TRAILING_TYPE trailingType = TRAILING_TYPE_PBI;  // тип трейлинга
double lot;                  // Лот

double signalBuffer[];                                                   // буфер для получения сигнала из индикатора
double extrLeftTime[];                                                   // буфер для хранения времени левых экстремумов
double extrRightTime[];                                                  // буфер для хранения времени правых экстремумов
double pbiBuffer[];                                                      // буфер для хранения индикатора PriceBasedIndicator

int    copiedSmydSTOC;                                                   // переменная для проверки копирования буфера сигналов расхождения
int    copiedLeftExtr;                                                   // переменная для проверки копирования буфера левых экстремумов
int    copiedRightExtr;                                                  // переменная для проверки копирования буфера правых экстремумов
int    copiedPBI;                                                        // переменная для проверки копирования буфера PBI

// переменные для хранения минимума и максимума между экстремумами расхождения
double minBetweenExtrs;
double maxBetweenExtrs;

// переменные для хранения значений тейк профита и уровня лимит ордеров  
int    stopLoss;           // переменная для хранения стоп лосса
int    takeProfit;         // переменная для хранения тейк профита
int    limitOrderLevel;    // переменная для хранения уровня отложенного ордера

int OnInit()
{
 symbol = Symbol();
 period = Period();
 lot = 1;
 
 trailingType = TRAILING_TYPE_PBI;  // тип трейлинга
 historyDepth = 1000;
 // выделяем память под объект тороговой библиотеки
 isNewBar = new CisNewBar(symbol, period);
 ctm = new CTradeManager(); 
 handlePBIcur = iCustom(symbol, period, "PriceBasedIndicator",historyDepth, percentage_ATR_cur, difToTrend_cur);
 if ( handlePBIcur == INVALID_HANDLE)
  {
   Print("Ошибка при инициализации эксперта ONODERA. Не удалось создать хэндл PriceBasedIndicator");
   return(INIT_FAILED);
  }
 // создаем хэндл индикатора ShowMeYourDivSTOC
 handleSmydSTOC = iCustom (symbol,period,"smydSTOC");   
 if ( handleSmydSTOC == INVALID_HANDLE )
 {
  Print("Ошибка при инициализации эксперта ONODERA. Не удалось создать хэндл ShowMeYourDivSTOC");
  return(INIT_FAILED);
 }   
 return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
 // освобождаем буферы
 ArrayFree(signalBuffer);
 ArrayFree(extrLeftTime);
 ArrayFree(extrRightTime);
 ArrayFree(pbiBuffer);   
 // удаляем объект класса TradeManager
 delete isNewBar;
 delete ctm;
 // удаляем индикаторы
 IndicatorRelease(handleSmydSTOC);
 IndicatorRelease(handlePBIcur);  
}

void OnTick()
{
 ctm.OnTick();
 ctm.DoTrailing();  
 // выставляем переменные проверки копирования буферов сигналов и экстремумов в начальное значение
 copiedSmydSTOC  = -1;
 copiedLeftExtr  = -1;
 copiedRightExtr = -1;
 copiedPBI       = -1;
 // если сформирован новый бар
 if (isNewBar.isNewBar() > 0)
 {
  // пытаемся скопировать буферы 
  copiedSmydSTOC  = CopyBuffer(handleSmydSTOC,2,0,1,signalBuffer);
  copiedLeftExtr  = CopyBuffer(handleSmydSTOC,3,0,1,extrLeftTime);
  copiedRightExtr = CopyBuffer(handleSmydSTOC,4,0,1,extrRightTime);
  copiedPBI       = CopyBuffer(handlePBIcur  ,4,1,1,pbiBuffer);
  // проверка на успешность копирования всех буферов
  if (copiedSmydSTOC < 1 || copiedLeftExtr < 1 || copiedRightExtr < 1 || copiedPBI < 1)
  {
   PrintFormat("Не удалось прогрузить все буферы Error=%d",GetLastError());
   return;
  }   

  if ( signalBuffer[0] == BUY)  // получили расхождение на покупку
  { 
   // вычислили стоп лосс
   stopLoss = CountStoploss(1);
   // условия открытия позиции на BUY на немедленное исполнение
   if (  (pbiBuffer[0] == MOVE_TYPE_TREND_UP           || 
          pbiBuffer[0] == MOVE_TYPE_TREND_UP_FORBIDEN  ||
          pbiBuffer[0] == MOVE_TYPE_CORRECTION_DOWN)   ||     
          !use_limits                                  ||
         (flat_as_instant  && pbiBuffer[0] == MOVE_TYPE_FLAT)
      )
   {
    // то мы просто открываемся на BUY немедленного исполнения
    ctm.OpenUniquePosition(symbol,period, OP_BUY, lot, stopLoss, takeProfit, trailingType, 0, 0, 0, handlePBIcur, priceDifference);         
   }
   else
   {
    // иначе мы используем LIMIT ордера
    if ( GetMaxAndMinBetweenExtrs() )  // если удалось вычислить максимумы и минимумы
    {
     // вычисляем тейк профит 
     takeProfit = int(2*(maxBetweenExtrs-minBetweenExtrs)/_Point);
     //  получаем текущую цену
     currentPrice = SymbolInfoDouble(symbol,SYMBOL_ASK);           
     //  уровень лимит ордера
     limitOrderLevel =  (currentPrice-maxBetweenExtrs)/_Point;
     // и открываем позицию лимит ордером на SELL
     if (limitOrderLevel <= SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL))
     {
      ctm.OpenUniquePosition(symbol,period, OP_BUY, lot, stopLoss, takeProfit, trailingType, 0, 0, 0, handlePBIcur, priceDifference);         
     }
     else
     { 
      ctm.OpenUniquePosition(symbol,period,OP_SELLLIMIT,lot,stopLoss,takeProfit, trailingType, 0, 0, 0, handlePBIcur, limitOrderLevel);
     }
    }
   }
  }  // END OF BUY
  
  if ( signalBuffer[0] == SELL) // получили расхождение на продажу
  {  
   // вычислили стоп лосс
   stopLoss = CountStoploss(-1);
   // условия открытия позиции на немедленное исполнение
   
   if (  (pbiBuffer[0] == MOVE_TYPE_TREND_DOWN          || 
          pbiBuffer[0] == MOVE_TYPE_TREND_DOWN_FORBIDEN ||
          pbiBuffer[0] == MOVE_TYPE_CORRECTION_UP)      ||     
          !use_limits                                   ||
         (flat_as_instant && pbiBuffer[0] == MOVE_TYPE_FLAT)
      )
   {
    // то мы просто открываемся на SELL немедленного исполнения
    ctm.OpenUniquePosition(symbol,period, OP_SELL, lot, stopLoss, takeProfit, trailingType, 0, 0, 0, handlePBIcur, priceDifference);        
   }
   else
   {
    // иначе мы использует LIMIT ордера
    if ( GetMaxAndMinBetweenExtrs() )  // если удалось вычислить максимумы и минимумы
    {
     // вычисляем тейк профит 
     takeProfit = int(2*(maxBetweenExtrs-minBetweenExtrs)/_Point);
     //  получаем текущую цену
     currentPrice = SymbolInfoDouble(symbol,SYMBOL_ASK);            
     //  уровень лимит ордера
     limitOrderLevel =  (currentPrice-minBetweenExtrs)/_Point;
     // и открываем позицию лимит ордером на BUY
     if (limitOrderLevel <= SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL))
     {
      ctm.OpenUniquePosition(symbol,period, OP_SELL, lot, stopLoss, takeProfit, trailingType, 0, 0, 0, handlePBIcur, priceDifference);        
     }
     else
     {
      ctm.OpenUniquePosition(symbol,period,OP_BUYLIMIT,lot,stopLoss,takeProfit, trailingType, 0, 0, 0, handlePBIcur, limitOrderLevel);
     }
    }        
   }
  }  // END OF SELL
 }  
}

// функция вычисляет стоп лосс
int CountStoploss(int point)
{
 int stoploss = 0;
 int direction;
 double priceAB;
 double bufferStopLoss[];
 ArraySetAsSeries(bufferStopLoss, true);
 ArrayResize(bufferStopLoss, historyDepth);
 
 int extrBufferNumber;
 if (point > 0)
 {
  extrBufferNumber = 6;
  priceAB = SymbolInfoDouble(symbol, SYMBOL_ASK);
  direction = 1;
 }
 else
 {
  extrBufferNumber = 5; // Если point > 0 возьмем буфер с минимумами, иначе с максимумами
  priceAB = SymbolInfoDouble(symbol, SYMBOL_BID);
  direction = -1;
 }
 
 int copiedPBI = -1;
 for(int attempts = 0; attempts < 25; attempts++)
 {
  Sleep(100);
  copiedPBI = CopyBuffer(handlePBIcur, extrBufferNumber, 0,historyDepth, bufferStopLoss);
 }
 if (copiedPBI < historyDepth)
 {
  PrintFormat("%s Не удалось скопировать буфер bufferStopLoss", MakeFunctionPrefix(__FUNCTION__));
  return(0);
 }
 
 for(int i = 0; i < historyDepth; i++)
 {
  if (bufferStopLoss[i] > 0)
  {
   if (LessDoubles(direction*bufferStopLoss[i], direction*priceAB))
   {
    stoploss = (int)(MathAbs(bufferStopLoss[i] - priceAB)/Point()) + ADD_TO_STOPPLOSS;
    break;
   }
  }
 }
 if (stoploss <= 0)
 {
  PrintFormat("Не поставили стоп на экстремуме");
  stoploss = SymbolInfoInteger(symbol, SYMBOL_SPREAD) + ADD_TO_STOPPLOSS;
 }
 PrintFormat("%s StopLoss = %d",MakeFunctionPrefix(__FUNCTION__), stoploss);
 return(stoploss);
}

// функция вычисляет минимум и максимум между двумя экстремумами
bool  GetMaxAndMinBetweenExtrs()
 {
  double tmpLow[];           // временный буфер низких цен
  double tmpHigh[];          // временный буфер высоких цен
  int    copiedHigh = -1;    // переменная для проверки копирования буфера высоких цен
  int    copiedLow  = -1;    // переменная для проверки копирования буфера низких цен
  int    n_bars;             // количество скопированных баров
  for (int attempts=0;attempts<25;attempts++)
   {
    copiedHigh = CopyHigh(symbol,period,datetime(extrLeftTime[0]),datetime(extrRightTime[0]),tmpHigh);
    copiedLow  = CopyLow (symbol,period,datetime(extrLeftTime[0]),datetime(extrRightTime[0]),tmpLow);    
    Sleep(100);
   }
  n_bars = Bars(symbol,period,datetime(extrLeftTime[0]),datetime(extrRightTime[0]));
  if (copiedHigh < n_bars || copiedLow < n_bars)
   {
    Print("Ошибка работы эксперта ONODERA. Не удалось скопировать буферы высоких и\или низких цен для поиска максимума и минимума");
    return (false);
   }
  // вычисляем максимум цены
  maxBetweenExtrs = tmpHigh[ArrayMaximum(tmpHigh)];
  // вычисляем минимум цены
  minBetweenExtrs = tmpLow[ArrayMinimum(tmpLow)];
  return (true);
 }
 