//+------------------------------------------------------------------+
//|                                                      ONODERA.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              http://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2013, MetaQuotes Software Corp."
#property link      "http://www.mql5.com"
#property version   "1.00"
// подсключение библиотек 
#include <TradeManager\TradeManager.mqh>        // подключение торговой библиотеки
#include <Lib CisNewBar.mqh>                    // для проверки формирования нового бара
#include <CompareDoubles.mqh>                   // для проверки соотношения  цен
#include <Constants.mqh>                        // библиотека констант
#include <ChartObjects/ChartObjectsLines.mqh>      // для рисования линий расхождения
#define ADD_TO_STOPPLOSS 50
// константы сигналов
#define BUY   1    
#define SELL -1

//+------------------------------------------------------------------+
//| Эксперт, основанный на расхождении MACD                          |
//+------------------------------------------------------------------+                                                                 
   
// входные параметры
sinput string base_param                           = "";                 // БАЗОВЫЕ ПАРАМЕТРЫ ЭКСПЕРТА
input  double lot                                  = 0.1;                // Лот         
input  int    spread                               = 300;                // Размер спреда       
input  int    koLock                               = 2;                  // коэффициент запрета на вход
sinput string trailingStr                          = "";                 // ПАРАМЕТРЫ трейлинга
input ENUM_TRAILING_TYPE trailingType = TRAILING_TYPE_PBI;               // тип трейлинга
input int     trStop                               = 100;                // Trailing Stop
input int     trStep                               = 100;                // Trailing Step
input int     minProfit                            = 250;                // минимальная прибыль
input bool    use19Lines                           = false;              // флаг использования уровней
// структура уровней
struct bufferLevel
 {
  double price[];  // цена уровня
  double atr[];    // ширина уровня
 };
// объекты
CTradeManager    *ctm;                                                   // указатель на объект торговой библиотеки
static CisNewBar *isNewBar;                                              // для проверки формирования нового бара
SPositionInfo pos_info;
STrailing trailing;
// хэндлы индикаторов 
int handleSmydSTOC;                                                      // хэндл индикатора smySTOC
int handle_PBI;                                                          // хэндл PriceBasedIndicator
int handle_19Lines;                                                      // хэндл 19 Lines
// переменные эксперта
int    stopLoss;                                                         // переменная для хранения действительного стоп лосса
double currentPrice;                                                     // текущая цена
double lenClosestUp;                                                     // расстояние до ближайшего уровня сверху
double lenClosestDown;                                                   // расстояние до ближайшего уровня снизу    
double lastRightExtr=0;                                                  // значение последней даты правого экстремума расхождения
// буферы 
double signalBuffer[];                                                   // буфер для получения сигнала из индикатора smydStochastic
double dateRightExtr[];                                                  // буфер для получения времени прихода правого экстремума расхождения
bufferLevel buffers[10];                                                  // буфер уровней

CChartObjectHLine  horLine;                                              // объект класса вертикальной линии
int OnInit()
{
 // выделяем память под объект тороговой библиотеки
 isNewBar = new CisNewBar(_Symbol, _Period);
 ctm = new CTradeManager(); 
 handle_PBI = iCustom(_Symbol, _Period, "PriceBasedIndicator", 1000, 1, 1.5);
 if(handle_PBI == INVALID_HANDLE)                                //проверяем наличие хендла индикатора
  {
   Print("Не удалось получить хендл Price Based Indicator");      //если хендл не получен, то выводим сообщение в лог об ошибке
  }
 // если используются уровни для запрета на вход
 if (use19Lines)
  {
   handle_19Lines = iCustom(_Symbol,_Period,"NineteenLines",
                            "",3,3,
                            "","",true,0.1,
                            "",true,0.15,
                            "",true,0.25,
                            "",true,0.25,
                            "",true,0.25,
                            "",false
                           );     
   if (handle_19Lines == INVALID_HANDLE)
    {
     Print("Не удалось получить хэндл NineteenLines");
     return (INIT_FAILED);
    }
   }    
 // создаем хэндл индикатора ShowMeYourDivMACD
 handleSmydSTOC = iCustom (_Symbol,_Period,"smydSTOC");   
 if ( handleSmydSTOC == INVALID_HANDLE )
 {
  Print("Ошибка при инициализации эксперта TradeOnStochastic. Не удалось создать хэндл smydSTOC");
  return(INIT_FAILED);
 }     
 pos_info.tp = 0;
 pos_info.volume = lot;
 pos_info.expiration = 0;
 pos_info.priceDifference = 0;
  
 trailing.trailingType = trailingType;
 trailing.minProfit    = minProfit;
 // если для трейлинга используется PBI
 if (trailingType == TRAILING_TYPE_PBI)
  {
   trailing.trailingStop = trStop;
   trailing.trailingStep = trStep;
   trailing.handlePBI    = handle_PBI; 
  }
 else
  {
   trailing.trailingStop = 0;
   trailing.trailingStep = 0;
   trailing.handlePBI    = 0;
  }
 return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
 // удаляем объект класса TradeManager
 delete isNewBar;
 delete ctm;
 // удаляем индикатор 
 IndicatorRelease(handleSmydSTOC);
 // если использовать уровни для запрета на вход
 if (use19Lines)
  IndicatorRelease(handle_19Lines);
 IndicatorRelease(handle_PBI);
}

void OnTick()
{
 ctm.OnTick();
 if (trailingType != TRAILING_TYPE_NONE)
 ctm.DoTrailing();
 // если используются уровни для запрета на вход
 if (use19Lines)
  {
   // если не удалось прогрузить буферы уровней
   if (!UploadBuffers())
    return;
  }
 // если сформирован новый бар
   if (CopyBuffer(handleSmydSTOC,2,0,1,signalBuffer) < 1 || CopyBuffer(handleSmydSTOC,4,0,1,dateRightExtr) < 1 )
    {
     PrintFormat("Не удалось прогрузить все буферы Error=%d",GetLastError());
     return;
    }   
  
   if ( signalBuffer[0] == BUY)  // получили расхождение на покупку
     { 
      // если последний полученный сигнал не равен предыдущему
      if ( !EqualDoubles( lastRightExtr,dateRightExtr[0]) ) 
       {
        currentPrice = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
        // если используются уровни для запрета на вход
        if (use19Lines)
         {
          // получаем расстояния до ближайших уровней снизу и сверху
          lenClosestUp   = GetClosestLevel(BUY);
          lenClosestDown = GetClosestLevel(SELL);
          // если ближайший уровень сверху отсутствует, или дальше билжайшего уровня снизу
          if (lenClosestUp != 0 && LessOrEqualDoubles(lenClosestUp, lenClosestDown*koLock) )
           return;
         }
          stopLoss = CountStoploss(BUY);        
          // то открываем позицию на BUY
          pos_info.type = OP_BUY;
          pos_info.sl = stopLoss;
          ctm.OpenUniquePosition(_Symbol,_Period, pos_info, trailing,spread);                  
        }
       // сохраняем последний сигнал
       lastRightExtr = dateRightExtr[0];
     }
   if ( signalBuffer[0] == SELL) // получили расхождение на продажу
     {
      // если последний полученный сигнал не равен предыдущему
      if ( !EqualDoubles( lastRightExtr,dateRightExtr[0]) )
       {
        currentPrice = SymbolInfoDouble(_Symbol,SYMBOL_BID);  
        // если используются уровни для запрета на вход
        if (use19Lines)
         {      
         // получаем расстояния до ближайших уровней снизу и сверху
         lenClosestUp   = GetClosestLevel(BUY);
         lenClosestDown = GetClosestLevel(SELL);      
         // если ближайший уровень снизу отсутствует, или дальше ближайшего уровня сверху
         if (lenClosestDown != 0 && LessOrEqualDoubles(lenClosestDown,lenClosestUp*koLock) )
           return;
         }
          stopLoss = CountStoploss(SELL);
          // то открываем позицию на SELL
          pos_info.type = OP_SELL;
          pos_info.sl = stopLoss;
          ctm.OpenUniquePosition(_Symbol,_Period, pos_info, trailing,spread);                   
       }
      //сохраняем последний правый экстремум расхождения
      lastRightExtr = dateRightExtr[0]; 
     }
}

int CountStoploss(int point)
{
 int stopLoss = 0;
 int direction;
 double priceAB;
 double bufferStopLoss[];
 ArraySetAsSeries(bufferStopLoss, true);
 ArrayResize(bufferStopLoss, 1000);
 
 int extrBufferNumber;
 if (point > 0)
 {
  extrBufferNumber = 6;
  priceAB = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
  direction = 1;
 }
 else
 {
  extrBufferNumber = 5; // Если point > 0 возьмем буфер с минимумами, иначе с максимумами
  priceAB = SymbolInfoDouble(_Symbol, SYMBOL_BID);
  direction = -1;
 }
 
 int copiedPBI = -1;
 for(int attempts = 0; attempts < 25; attempts++)
 {
  //Sleep(100);
  copiedPBI = CopyBuffer(handle_PBI, extrBufferNumber, 0,1000, bufferStopLoss);
 }
 if (copiedPBI < 1000)
 {
  PrintFormat("%s Не удалось скопировать буфер bufferStopLoss", MakeFunctionPrefix(__FUNCTION__));
  return(0);
 }
 for(int i = 0; i < 1000; i++)
 {
  if (bufferStopLoss[i] > 0)
  {
   if (LessDoubles(direction*bufferStopLoss[i], direction*priceAB))
   {
    stopLoss = (int)(MathAbs(bufferStopLoss[i] - priceAB)/Point()) + ADD_TO_STOPPLOSS;
    break;
   }
  }
 }
 if (stopLoss <= 0)  
 {
  PrintFormat("Не поставили стоп на экстремуме");
  stopLoss = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) + ADD_TO_STOPPLOSS;
 }
 return(stopLoss);
}

bool UploadBuffers ()   // получает последние значения уровней
 {
  int copiedPrice;
  int copiedATR;
  int indexPer;
  int indexBuff;
  int indexLines = 0;
  for (indexPer=0;indexPer<5;indexPer++)
   {
    for (indexBuff=0;indexBuff<2;indexBuff++)
     {
      copiedPrice = CopyBuffer(handle_19Lines,indexPer*8+indexBuff*2+4,  0,1,  buffers[indexLines].price);
      copiedATR   = CopyBuffer(handle_19Lines,indexPer*8+indexBuff*2+5,  0,1,buffers[indexLines].atr);
      if (copiedPrice < 1 || copiedATR < 1)
       {
        Print("Не удалось прогрузить буферы индикатора NineTeenLines");
        return (false);
       }
      indexLines++;
     }
   }
  return(true);     
 }
 // возвращает ближайший уровень к текущей цене
 double GetClosestLevel (int direction) 
  {
   double cuPrice = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double len = 0;  //расстояние до цены от уровня
   double tmpLen; 
   int    index;
   int    savedInd;
   switch (direction)
    {
     case BUY:  // ближний сверху
      for (index=0;index<10;index++)
       {
        // если уровень выше
        if ( GreatDoubles((buffers[index].price[0]-buffers[index].atr[0]),cuPrice)  )
         {
          tmpLen = buffers[index].price[0] - buffers[index].atr[0] - cuPrice;
          if (tmpLen < len || len == 0)
           {
            savedInd = index;
            len = tmpLen;
           }  
         }
       }
     break;
     case SELL: // ближний снизу
      for (index=0;index<10;index++)
       {
        // если уровень ниже
        if ( LessDoubles((buffers[index].price[0]+buffers[index].atr[0]),cuPrice)  )
          {
           tmpLen = cuPrice - buffers[index].price[0] - buffers[index].atr[0] ;
           if (tmpLen < len || len == 0)
            {
             savedInd = index;
             len = tmpLen;
            }
          }
       }     
      break;
   }
   return (len);
  }