//+------------------------------------------------------------------+
//|                                                 EvgenysBrain.mqh |
//|                        Copyright 2015, MetaQuotes Software Corp. |
//|                                              http://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2015, MetaQuotes Software Corp."
#property link      "http://www.mql5.com"
#property version   "1.00"

#include <Brain.mqh>
#include <ChartObjects/ChartObjectsLines.mqh> // для рисования линий тренда
#include <DrawExtremums/CExtrContainer.mqh>   // контейнер экстремумов (попробовать удалить после появления контейнера трендов)

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
input double percent = 0.1; // для контейнера движений (скорее всего станет константой)

 
class CEvgenysBrain: CBrain
{
private:
 CisNewBar *_isNewBar;
 CContainerBuffers *_conbuf;
 CExtrContainer *_extremums; // контейнер экстремумов
 CExtremum *extr1; //Для вычисления коридоров (нахождения разности и пр.)
 CExtremum *extr2;
 CExtremum *extr3; 
 CExtremum *extr4;
 ENUM_TIMEFRAMES _period;
 ENUM_TM_POSITION_TYPE signalPositionType;
 string _symbol;
 int _trend;       // текущий тренд 1-й типа
 int _prevTrend;   // предыдущий тренд
 int _magic;       // уникальный номер для этого робота
 ENUM_SIGNAL_FOR_TRADE _current_direction; // фиксирование сосотояния шаблона (SEll, BUY, DISCORD(0) - торговля запрещена)
 double curBid;   // текущая цена bid
 double curAsk;   // текущая цена Ask
 double prevBid;  // предыдущая цена bid
 double priceTrendUp; // цена верхней линии тренда
 double priceTrendDown; // цена нижней линии тренда
 double H1,H2; // расстояния между экстремумами
 double channelH; // ширина канала
 double horPrice;
 double pbiMove; // значение движение на PBI в текущий момент
 // массивы и буфера
 MqlRates rates[]; // буфер котировок
 CChartObjectTrend  trendLine; // объект класса трендовой линии
 CChartObjectHLine  horLine; // объект класса горизонтальной линии

public:
                     CEvgenysBrain(string symbol, ENUM_TIMEFRAMES period, CExtrContainer *extremums, CContainerBuffers *conbuf);
                    ~CEvgenysBrain();
            virtual ENUM_TM_POSITION_TYPE GetSignal();
            virtual long GetMagic(){return _magic;}
            virtual ENUM_SIGNAL_FOR_TRADE GetDirection(){return _current_direction;}
            virtual ENUM_TIMEFRAMES GetPeriod(){return _period;}
            virtual string  GetName(){return StringFormat("CEvgenysBrain_%s",PeriodToString(_period));};
            virtual int  CountTakeProfit();
            virtual int  CountStopLoss();
            virtual int  GetPriceDifference();
            virtual int  GetExpiration();
                    int  CountStopLossForTrendLines();
                    int  IsTrendNow();
                    void UploadOnEvent();
                    bool CheckClose();
                    void DrawLines();
                    void DeleteLines();
                    
                    
};

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
CEvgenysBrain::CEvgenysBrain(string symbol,ENUM_TIMEFRAMES period, CExtrContainer *extremums, CContainerBuffers *conbuf) // удалть хэндл  и передать CExtrContainer
{
 _trend = 0;       // текущий тренд 1-й типа
 _prevTrend = 0;   // предыдущий тренд
 _current_direction = SELL;
 _symbol = symbol;
 _period = period;
 _isNewBar = new CisNewBar(_symbol, _period);
 _isNewBar.isNewBar();
 _extremums = extremums;
 _conbuf = conbuf;
 _trend = IsTrendNow();
  if (_trend)
  {
   // строим линии 
   DrawLines ();    
  }
  
 // сохраняем цены  
 curBid = SymbolInfoDouble(_symbol, SYMBOL_BID);   // стоит ли использовать конбуф, ведь таким образом данные будут точнее
 curAsk = SymbolInfoDouble(_symbol, SYMBOL_ASK);
 prevBid = curBid;
}
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
CEvgenysBrain::~CEvgenysBrain()
{
 DeleteLines ();
 delete _isNewBar;
}
//+------------------------------------------------------------------+

ENUM_TM_POSITION_TYPE CEvgenysBrain::GetSignal()
{
 curBid = SymbolInfoDouble(_symbol,SYMBOL_BID); 
 curAsk = SymbolInfoDouble(_symbol,SYMBOL_ASK);
 signalPositionType = OP_UNKNOWN;
  
 if (CheckClose()) // разрыв шаблона return DISCORD
 { 
  _current_direction = NO_SIGNAL;
  signalPositionType = OP_UNKNOWN;
  return signalPositionType;
 }

  // если текущее движение - тренд 1-й типа вверх
 if (_trend == 1)
 {
  // если сформировался новый бар
  if (_isNewBar.isNewBar() > 0)
  {
   priceTrendUp = ObjectGetValueByTime(0,"trendUp", TimeCurrent());
   priceTrendDown = ObjectGetValueByTime(0,"trendDown", TimeCurrent());   
   channelH = priceTrendUp - priceTrendDown;   // вычисляю ширину канала
   log_file.Write(LOG_DEBUG, StringFormat("channelH(%f) = priceTrendUp(%f) - priceTrendDown(%f)", channelH, priceTrendUp, priceTrendDown));  
   //PrintFormat("Close[1] (%f) > Open[1] (%f) && Close[2] (%f) < Open[2] (%f) && |curBid - priceTrendDown| (%f) < channelH*0.2 (%f)", 
   //_conbuf.GetClose(_period).buffer[1],_conbuf.GetOpen(_period).buffer[1],_conbuf.GetClose(_period).buffer[2], _conbuf.GetOpen(_period).buffer[2],curBid-priceTrendDown,channelH*0.2);   
   // если цена закрытия на последнем баре выше цены открытия (в нашу сторону), а на предыдущем баре - обратная ситуевина
   if ( GreatDoubles(_conbuf.GetClose(_period, 1), _conbuf.GetOpen(_period, 1)) && LessDoubles(_conbuf.GetClose(_period, 2),_conbuf.GetOpen(_period, 2)) &&  // если последний бар закрылся в нашу сторону, а прошлый - в противоположную
        LessOrEqualDoubles(MathAbs(curBid-priceTrendDown), channelH * 0.2)                             // если текущая цена находится возле нижней границы канала тренда 
      )
   {
    log_file.Write(LOG_DEBUG, StringFormat("Close[1] (%f) > Open[1] (%f) && Close[2] (%f) < Open[2] (%f) && |curBid(%f) - priceTrendDown| (%f) < channelH*0.2 (%f)", 
    _conbuf.GetClose(_period).buffer[1],_conbuf.GetOpen(_period).buffer[1],_conbuf.GetClose(_period).buffer[2], _conbuf.GetOpen(_period).buffer[2],curBid, MathAbs(curBid-priceTrendDown),channelH*0.2));
    _current_direction = BUY;
    signalPositionType = OP_BUY;

   }
  }
 }
 // если текущее движение - тренд 1-й типа вниз
 if (_trend == -1)
 {
  // если сформировался новый бар
  if (_isNewBar.isNewBar() > 0)
  {
   priceTrendUp = ObjectGetValueByTime(0,"trendUp", TimeCurrent());
   priceTrendDown = ObjectGetValueByTime(0,"trendDown", TimeCurrent());   
   channelH = priceTrendUp - priceTrendDown;   // вычисляю ширину канала   
   // если цена закрытия на последнем баре ниже цены открытия (в нашу сторону), а на предыдущем баре - обратная ситуевина
   if ( LessDoubles(_conbuf.GetClose(_period,1), _conbuf.GetOpen(_period,1)) && GreatDoubles(_conbuf.GetClose(_period,2),_conbuf.GetOpen(_period,2)) &&  // если последний бар закрылся в нашу сторону, а прошлый - в противоположную
        LessOrEqualDoubles(MathAbs(curBid-priceTrendUp),channelH * 0.2)                             // если текущая цена находится возле нижней границы канала тренда 
      )
   {
   log_file.Write(LOG_DEBUG, StringFormat("Close[1] (%f) < Open[1] (%f) && Close[2] (%f) > Open[2] (%f) && |curBid(%f) - priceTrendDown| (%f) < channelH*0.2 (%f)", 
    _conbuf.GetClose(_period,1),_conbuf.GetOpen(_period,1),_conbuf.GetClose(_period,2), _conbuf.GetOpen(_period,2),curBid, MathAbs(curBid-priceTrendDown),channelH*0.2));
    _current_direction =  SELL;
    signalPositionType = OP_SELL;
   }
  }
 } 

 prevBid = curBid;
 if (_trend != 0)
  _prevTrend = _trend; 
  
 return signalPositionType;
}

bool CEvgenysBrain::CheckClose()
{
 if (_prevTrend == -_trend)
  return true;
 else
  return false;
}


// вернет true, если тренд валиден
int  CEvgenysBrain::IsTrendNow ()
{
 double h1,h2;
 extr1 = _extremums.GetFormedExtrByIndex(0, EXTR_BOTH);
 extr2 = _extremums.GetFormedExtrByIndex(1, EXTR_BOTH);
 extr3 = _extremums.GetFormedExtrByIndex(2, EXTR_BOTH);
 extr4 = _extremums.GetFormedExtrByIndex(3, EXTR_BOTH);
 
 // вычисляем расстояния h1, h2
 h1 = MathAbs(extr1.price - extr3.price);
 h2 = MathAbs(extr2.price - extr4.price);
 // если тренд вверх 
 log_file.Write(LOG_DEBUG, StringFormat("extr1 = %f extr2 = %f extr3 = %f extr4 = %f ", extr1.price,extr2.price,extr3.price,extr4.price));
 if (GreatDoubles(extr1.price,extr3.price) && GreatDoubles(extr2.price,extr4.price)) // можно переписать покороче (через ИЛИ - ретёрн -дирекшн)
 {
  // если последний экстремум - вниз
  if (extr1.direction == -1) 
  {
   H1 = extr2.price - extr3.price;
   H2 = extr4.price - extr1.price;
   // если наша трендовая линия нас удовлетворяет
   if (GreatDoubles(h1, H1*percent) && GreatDoubles(h2, H2*percent) )
   {
    log_file.Write(LOG_DEBUG, " А вот и тренд вверх сформировался");
    return (1);
   }
  }
 }
 // если тренд вниз
 if (LessDoubles(extr1.price,extr3.price) && LessDoubles(extr2.price,extr4.price))
 {
  // если  последний экстремум - вверх
  if (extr1.direction == 1)
  {
   H1 = extr2.price - extr3.price;
   H2 = extr4.price - extr1.price;
   // если наша трендования линия нас удовлетворяет
   if (GreatDoubles(h1, H1 * percent) && GreatDoubles(h2, H2 * percent))    
   log_file.Write(LOG_DEBUG, " А вот и тренд вниз сформировался");
    return (-1);
  }
 }   
 return (0);   
}

// функция отрисовывает линии по экстремумам  
void CEvgenysBrain::DrawLines()
{
 // то создаем линии по точкам
 if (extr1.direction == 1)
 {
  trendLine.Create(0,"trendUp",0,extr3.time,extr3.price,extr1.time, extr1.price);   // верхняя  линия
  ObjectSetInteger(0,"trendUp",OBJPROP_RAY_RIGHT,1);
  trendLine.Create(0,"trendDown",0,extr4.time,extr4.price,extr2.time,extr2.price); // нижняя  линия
  ObjectSetInteger(0,"trendDown",OBJPROP_RAY_RIGHT,1);   
  if (_trend == 1)
  {
   horLine.Create(0,"horLine",0,extr1.price); // горизонтальная линия    
   horPrice = extr1.price;    
  } 
  if (_trend == -1)
  {
   horLine.Create(0,"horLine",0,extr2.price); // горизонтальная линия       
   horPrice = extr1.price;         
  }        
 }
 // то создаем линии по точкам
 if (extr1.direction == -1)
 {
  trendLine.Create(0, "trendDown", 0, extr3.time, extr3.price, extr1.time, extr1.price); // нижняя  линия
  ObjectSetInteger(0, "trendDown", OBJPROP_RAY_RIGHT, 1);
  trendLine.Create(0, "trendUp", 0, extr4.time, extr4.price, extr2.time, extr2.price);   // верхняя  линия
  ObjectSetInteger(0, "trendUp", OBJPROP_RAY_RIGHT, 1);   
  if (_trend == 1)
  {
   horLine.Create(0,"horLine", 0, extr2.price); // горизонтальная линия     
   horPrice = extr2.price;           
  } 
  if (_trend == -1)
  {
   horLine.Create(0,"horLine", 0, extr1.price); // горизонтальная линия      
   horPrice = extr1.price;          
  }          
 }   
} 

// функция удаляет линии с графика
void CEvgenysBrain::DeleteLines()
{
 ObjectDelete(0,"trendUp");
 ObjectDelete(0,"trendDown");
 ObjectDelete(0,"horLine");
}

// функция вычисляет стоп лосс для трендовых линий
int CEvgenysBrain::CountStopLossForTrendLines()
 {
  // если тренд вверх
  if (_trend == 1)
   {
    return (int((MathAbs(curBid-extr1.price) + H1*percent)/_Point));
   }
  // если тренд вниз
  if (_trend == -1)
   {
    return (int((MathAbs(curAsk-extr1.price) - H1*percent)/_Point));
   }   
  return (0);
 }
//---------------------------------------------------------------------------+
//         Функция UploadOnEvent()                                           |
//       включить в функцию OnChartEvent() при появлении событий             | 
//       о сформированном экстремуме (верхнем или нижнем)                    |
//---------------------------------------------------------------------------+
void CEvgenysBrain::UploadOnEvent(void)
{
   // удаляем линии с графика
  DeleteLines();
  log_file.Write(LOG_DEBUG, " Проверочка на наличие тренда по событию");
  _trend = IsTrendNow();
  if (_trend)
  {  
   // перерисовываем линии
   DrawLines();     
  }   
}

int CEvgenysBrain::CountStopLoss(void)
{
 int stop_level;
 int sl;
 stop_level = (int)SymbolInfoInteger(_symbol, SYMBOL_TRADE_STOPS_LEVEL);
 sl = CountStopLossForTrendLines();
 if(sl > stop_level)
  return sl;
 else
 {
  log_file.Write(LOG_DEBUG, StringFormat("%s Выставленный СтопЛосс не соответствует алгоритму sl = %d", MakeFunctionPrefix(__FUNCTION__), stop_level));
  return stop_level;
 }
}

int CEvgenysBrain::CountTakeProfit()
{
 return 10 * CountStopLoss();
}
